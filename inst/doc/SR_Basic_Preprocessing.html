<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Vincent Porretta" />

<meta name="date" content="2016-09-27" />

<title>Basic VWP Preprocessing for SR Eyelink Data</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Basic VWP Preprocessing for SR Eyelink Data</h1>
<h4 class="author"><em>Vincent Porretta</em></h4>
<h4 class="date"><em>2016-09-27</em></h4>



<div id="before-using-vwpre" class="section level2">
<h2>Before using VWPre</h2>
<p>Before using this package a number of steps are required: First, your eye gaze data must have been collected using an SR Research Eyelink eye tracker. Second, your data must have been exported using SR Research Data Viewer software. For this basic example, it is assumed that you have specified an interest period relative to the onset of the critical stimulus in Data Viewer. However, this package is also able to preprocess data without a specified relative interest period. If you have not aligned your data to a particular message in Data Viewer, please refer to the vignette <code>SR_Message_Alignment</code> for functions related to this.</p>
<p>The Sample Report should be exported along with all available columns (this will ensure that you have all of the necessary columns for the functions contained in this package to work). Additionally, it is preferable to export to a .txt file rather than a .xlsx file.</p>
<p>The following preprocessing assumes that, in your experiment, interest area IDs and Labels were assigned consistently to the object types displayed on the screen. For example, in a typical VWP experiment, the target was always in interest area 1, the competitor was always in interest area 2, et cetera. This is typically done by dynamically moving the interest areas trial-by-trial to correspond with the position of the objects. If, instead, your interest areas were static and you have columns indicating the location of each object for each trial, you will need to reassign your interest areas. Specific functions for this are available in this package; please see the vignette <code>SR_Interest_Areas</code> for illustration. Once that is complete, you can follow the preprocessing procedure below. Note that the functions presented here are capable of handling data with a maximum of 8 interest areas. If you have more than 8 interest areas, it is necessary to adjust the source code to accommodate the number needed.</p>
<p>Lastly, the functions included here, internally make use of <code>dplyr</code> for manipulating and restructuring data. For more information about <code>dplyr</code>, please refer to its reference manual and extensive collection of vignettes.</p>
</div>
<div id="loading-the-package-and-the-data" class="section level2">
<h2>Loading the package and the data</h2>
<p>First, load the sample report. By default, Data Viewer will assign “.” to missing values; therefore it is important to include this in the na.strings parameter, so R will know how to handle any missing data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(VWPre)
VWdat &lt;-<span class="st"> </span><span class="kw">read.table</span>(<span class="st">&quot;1000HzData.txt&quot;</span>, <span class="dt">header =</span> T, <span class="dt">sep =</span> <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>, <span class="dt">na.strings =</span> <span class="kw">c</span>(<span class="st">&quot;.&quot;</span>, <span class="st">&quot;NA&quot;</span>))</code></pre></div>
<p>However, for the purposes of this vignette we will use the sample dataset included in the package.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(VWdat)</code></pre></div>
</div>
<div id="preparing-the-data" class="section level2">
<h2>Preparing the data</h2>
<div id="verifying-and-creating-necessary-columns" class="section level3">
<h3>Verifying and creating necessary columns</h3>
<p>In order for the functions in the package to work appropriately, the data need to be in a specific format. The <code>prep_data</code> function examines the presence and class of specific columns (<code>LEFT_INTEREST_AREA_ID</code>, <code>RIGHT_INTEREST_AREA_ID</code>, <code>LEFT_INTEREST_AREA_LABEL</code>, <code>RIGHT_INTEREST_AREA_LABEL</code>, <code>TIMESTAMP</code>, and <code>TRIAL_INDEX</code>) to ensure they are present in the data and appropriately assigned (e.g., categorical variables are encoded as factors). It also checks for columns <code>SAMPLE_MESSAGE</code>, <code>RIGHT_GAZE_X</code>, <code>RIGHT_GAZE_Y</code>, <code>LEFT_GAZE_X</code>, and <code>LEFT_GAZE_Y</code>, which are not required for basic preporcessing, but are needed to use the functions <code>align_msg</code> and <code>custom_ia</code>.</p>
<p>Additionally, the <code>Subject</code> parameter is used to specify the column corresponding to the subject identifier. Typical Data Viewer output contains a column called <code>RECORDING_SESSION_LABEL</code> which is the name of the column containing the subject identifier. The function will rename it <code>Subject</code> and will ensure it is encoded as a factor.</p>
<p>If your data contain a column corresponding to an item identifier please specify it in the <code>Item</code> parameter. In doing so, the function will standardize the name of the column to <code>Item</code> and will ensure it is encoded as a factor. If you don’t have an item identifier column, by default the value of this parameter is NA.</p>
<p>Lastly, a new column called <code>Event</code> will be created which indexes each unique recording sequence and corresponds to the combination of <code>Subject</code> and <code>TRIAL_INDEX</code>. This Event variable is required internally for subsequent operations. Should you choose to define the Event variable differently, you can override the default; however, do so cautiously as this may impact the performance of subsequent operations because it must index each time sequence in the data uniquely. Upon completion, the function prints a summary indicating the results.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat0 &lt;-<span class="st"> </span><span class="kw">prep_data</span>(<span class="dt">data =</span> VWdat, <span class="dt">Subject =</span> <span class="st">&quot;RECORDING_SESSION_LABEL&quot;</span>, <span class="dt">Item =</span> <span class="st">&quot;itemid&quot;</span>)</code></pre></div>
<pre><code>## Checking required columns...</code></pre>
<pre><code>##     All required columns are present in the data.</code></pre>
<pre><code>## Checking optional columns...</code></pre>
<pre><code>##     All optional columns are present in the data.</code></pre>
<pre><code>## Working on required columns...</code></pre>
<pre><code>##     RECORDING_SESSION_LABEL renamed to Subject.</code></pre>
<pre><code>##     Subject converted to factor.</code></pre>
<pre><code>##     itemid renamed to Item.</code></pre>
<pre><code>##     Item converted to factor.</code></pre>
<pre><code>##     LEFT_INTEREST_AREA_ID converted to numeric.</code></pre>
<pre><code>##     RIGHT_INTEREST_AREA_ID already numeric.</code></pre>
<pre><code>##     LEFT_INTEREST_AREA_LABEL converted to factor.</code></pre>
<pre><code>##     RIGHT_INTEREST_AREA_LABEL converted to factor.</code></pre>
<pre><code>##     TIMESTAMP already numeric.</code></pre>
<pre><code>##     TRIAL_INDEX already numeric.</code></pre>
<pre><code>##     Event variable created from Subject and TRIAL_INDEX</code></pre>
<pre><code>## Working on optional columns...</code></pre>
<pre><code>##     Optional column SAMPLE_MESSAGE already factor.</code></pre>
<pre><code>##     Optional column LEFT_GAZE_X converted to numeric.</code></pre>
<pre><code>##     Optional column LEFT_GAZE_Y converted to numeric.</code></pre>
<pre><code>##     Optional column RIGHT_GAZE_X already numeric.</code></pre>
<pre><code>##     Optional column RIGHT_GAZE_Y already numeric.</code></pre>
</div>
<div id="remove-unnecessary-columns" class="section level3">
<h3>Remove unnecessary columns</h3>
<p>At this point, it is safe to remove the columns which were output by Data Viewer, but that are not needed for preprocessing in using this package. Removing these will reduce the amount of system memory consumed and result in a final dataset that consume less disk space. This is done straightforwardly using <code>dplyr::select</code>, which can also accommodate both column names and regular expressions for matching. If using the sample data set included in this package, it is not necessary to do this step, as these columns have already been removed.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat0 &lt;-<span class="st"> </span><span class="kw">select</span>(dat0, -<span class="kw">starts_with</span>(<span class="st">&quot;AVERAGE&quot;</span>), -<span class="kw">starts_with</span>(<span class="st">&quot;DATA_&quot;</span>), 
               -<span class="kw">starts_with</span>(<span class="st">&quot;HTARGET&quot;</span>), -<span class="kw">starts_with</span>(<span class="st">&quot;IP&quot;</span>), 
               -<span class="kw">starts_with</span>(<span class="st">&quot;LEFT_ACCELLERATION&quot;</span>), -<span class="kw">starts_with</span>(<span class="st">&quot;LEFT_IN_&quot;</span>), 
               -<span class="kw">starts_with</span>(<span class="st">&quot;LEFT_PUPIL&quot;</span>), -<span class="kw">starts_with</span>(<span class="st">&quot;LEFT_VELOCITY&quot;</span>), 
               -<span class="kw">starts_with</span>(<span class="st">&quot;RESOLUTION&quot;</span>), -<span class="kw">starts_with</span>(<span class="st">&quot;RIGHT_ACCELLERATION&quot;</span>), 
               -<span class="kw">starts_with</span>(<span class="st">&quot;RIGHT_IN_&quot;</span>), -<span class="kw">starts_with</span>(<span class="st">&quot;RIGHT_PUPIL&quot;</span>), 
               -<span class="kw">starts_with</span>(<span class="st">&quot;RIGHT_VELOCITY&quot;</span>), -<span class="kw">starts_with</span>(<span class="st">&quot;SAMPLE_INDEX&quot;</span>),
               -<span class="kw">starts_with</span>(<span class="st">&quot;SAMPLE_BUTTON&quot;</span>), -<span class="kw">starts_with</span>(<span class="st">&quot;TARGET_&quot;</span>), 
               -<span class="kw">starts_with</span>(<span class="st">&quot;TRIAL_START&quot;</span>), -<span class="kw">starts_with</span>(<span class="st">&quot;VIDEO&quot;</span>))</code></pre></div>
</div>
<div id="relabel-na-samples-as-outside-any-interest-area" class="section level3">
<h3>Relabel NA samples as outside any interest area</h3>
<p>When the data were loaded, samples that were outside of any interest area were labeled as NA. The <code>relabel_na</code> function examines the interest area columns (<code>LEFT_INTEREST_AREA_ID</code>, <code>RIGHT_INTEREST_AREA_ID</code>, <code>LEFT_INTEREST_AREA_LABEL</code>, and <code>RIGHT_INTEREST_AREA_LABEL</code>) for cells containing NAs. It then assigns 0 to the ID columns and “Outside” to the LABEL columns) to indicate those eye gaze samples which fell outside of the interest areas defined in the study. The number of interest areas you defined in your experiment should be supplied to the parameter <code>NoIA</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat1 &lt;-<span class="st"> </span><span class="kw">relabel_na</span>(<span class="dt">data =</span> dat0, <span class="dt">NoIA =</span> <span class="dv">4</span>)</code></pre></div>
<pre><code>## LEFT_INTEREST_AREA_LABEL: Number of levels DO NOT match NoIA.</code></pre>
<pre><code>## RIGHT_INTEREST_AREA_LABEL: Number of levels match NoIA.</code></pre>
<p>Notice that the output informs us that the number of levels <code>LEFT_INTEREST_AREA_LABEL</code> does not match the number of interest areas listed in <code>NoIA</code>. This is because we only have data from the right eye (hence, all samples in <code>LEFT_INTEREST_AREA_LABEL</code> are listed as “Outside”).</p>
</div>
<div id="check-encoding-of-interest-areas" class="section level3">
<h3>Check encoding of interest areas</h3>
<p>The subsequent preprocessing requires that the interest area IDs are numerically coded, with values ranging from 0 (i.e., outside all interest areas) up to a maximum of 8. So, it’s important to check that the IDs present in the data set, conform to this. The <code>check_ia</code> functions does just this and indicates how those IDs are mapped to the interest area labels.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">check_ia</span>(<span class="dt">data =</span> dat1)</code></pre></div>
<pre><code>## Interest Area IDs for the right eye are coded appropriately.</code></pre>
<pre><code>##   ID      Label
## 1  0    Outside
## 2  1     Target
## 3  3  OnsetComp
## 4  2  RhymeComp
## 5  4 Distractor</code></pre>
<pre><code>## Interest Area IDs for the left eye are coded appropriately.</code></pre>
<pre><code>##   ID   Label
## 1  0 Outside</code></pre>
<p>If your interest area IDs do not conform to the required coding, or you would like to create new labels for your existing interest areas, please consult the vignette <code>SR_Interest_Areas</code>. That vignette illustrates how to relabel existing interest area codings (as well as remap the gaze data to entirely new interest areas, should you so desire).</p>
</div>
</div>
<div id="creating-the-time-series-column" class="section level2">
<h2>Creating the Time series column</h2>
<p>The function <code>create_time_series</code> creates a time series (a new column called <code>Time</code>) which is required for subsequent processing, plotting, and modeling of the data. It is common to export a period of time prior to the onset of the stimulus as a baseline. In this case, an offset (equal to the duration of the baseline period) must be applied to the time series, specified in the <code>Adj</code> parameter. In the example below, the data were exported with a 100ms pre-stimulus interval.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat2 &lt;-<span class="st"> </span><span class="kw">create_time_series</span>(<span class="dt">data =</span> dat1, <span class="dt">Adj =</span> -<span class="dv">100</span>)</code></pre></div>
<p>Note that if you have used the <code>align_msg</code> function (illustrated in the <code>SR_Align_Message</code> vignette), you may need to specify a column name in <code>Adj</code>. That column can be used to apply offsets specific to each recording event. Consult the vignette for further details.</p>
<p>The function <code>check_time_series</code> can be used to verify the time series. It outputs the unique start times present in the data. These will be the same standardized time point relative to the stimulus if you have exported your data from Data Viewer with pre-defined interest period relative to a message. By specifying the parameter <code>ReturnData = T</code>, the function can return a summary data frame that can be used to inspect the start time of each event.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">check_time_series</span>(<span class="dt">data =</span> dat2)</code></pre></div>
<pre><code>## [1] -100</code></pre>
</div>
<div id="selecting-which-eye-to-use" class="section level2">
<h2>Selecting which eye to use</h2>
<p>Depending on the design of the study, right, left, or both eyes may have been recorded during the experiment. Data Viewer outputs gaze data by placing it in separate columns for each eye (<code>LEFT_INTEREST_AREA_ID</code>, <code>LEFT_INTEREST_AREA_LABEL</code>, <code>RIGHT_INTEREST_AREA_ID</code>, <code>RIGHT_INTEREST_AREA_LABEL</code>). However, it is preferable to have gaze data in a single set of columns, regardless of which eye was recorded during the experiment. The function <code>select_recorded_eye</code> provides the functionality for this purpose, returning two new columns (<code>IA_ID</code> and <code>IA_LABEL</code>).</p>
<p>The function <code>select_recorded_eye</code> requires that the parameter <code>Recording</code> be specified. This parameter instructs the function about which eye(s) was used to record the gaze data. It takes one of four possible strings: “LandR”, “LorR”, “L”, or “R”. “LandR” should be used when any participant had both eyes recorded. “LorR” should be used when some participants had their left eye recorded and others had their right eye recorded “L” should be used when all participant had their left eye recorded. “R” should be used when all participant had their right eye recorded.</p>
<p>If in doubt, use the function <code>check_eye_recording</code> which will do a quick check to see if <code>LEFT_INTEREST_AREA_ID</code> and <code>RIGHT_INTEREST_AREA_ID</code> contain data. It will then suggest the appropriate Recording parameter setting. When in complete doubt, use “LandR”. The “LandR” setting requires an additional parameter (<code>WhenLandR</code>) to be specified. This instructs the function to select either the right eye or the left eye when data exist for both.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">check_eye_recording</span>(<span class="dt">data =</span> dat2)</code></pre></div>
<pre><code>## The dataset contains recordings for ONLY the right eye. 
##  Set the Recording parameter in select_recorded_eye() to 'R'.</code></pre>
<p>After executing, the function prints a summary of the output. While the function <code>check_eye_recording</code> indicated that the parameter <code>Recording</code> should be set to “R”, the example below sets the parameter to “LandR”, which can act as a “catch-all”. Consequently, in the summary, it can be seen that there were only recordings in the right eye.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat3 &lt;-<span class="st"> </span><span class="kw">select_recorded_eye</span>(<span class="dt">data =</span> dat2, <span class="dt">Recording =</span> <span class="st">&quot;R&quot;</span>, <span class="dt">WhenLandR =</span> <span class="st">&quot;Right&quot;</span>)</code></pre></div>
<pre><code>## Gaze data summary for 320 events:</code></pre>
<pre><code>## The final data frame contains 319 event(s) using gaze data from the right eye.</code></pre>
<pre><code>## The final data frame contains 1 event(s) with no samples falling within any interest area during the given time series.</code></pre>
</div>
<div id="binning-the-data" class="section level2">
<h2>Binning the data</h2>
<p>In order to obtain proportion looks, it is necessary to bin the data. That is, group samples in chunks of time, count the number of samples in each of the interest areas, and calculate the proportions based on the counts. The sampling rate at which the eye gaze data were recorded must be provided. For Eyelink trackers, this is typically 250Hz, 500Hz, or 1000Hz. If in doubt, use the function <code>check_samplingrate</code> to determine it. The sampling rate can then be supplied to the function <code>bin_prop</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">check_samplingrate</span>(dat3)</code></pre></div>
<pre><code>## Sampling rate(s) present in the data are: 1000 Hz.</code></pre>
<p>Note that the <code>check_samplingrate</code> function returns a printed message indicating the sampling rate(s) present in the data. Optionally, it can return a new column called <code>SamplingRate</code> by specifying the parameter <code>ReturnData</code> as TRUE. In the event that data were collected at different sampling rates, this column can be used to subset the dataset by the sampling rate before proceeding to the next processing step.</p>
<p>The function <code>bin_prop</code> calculates the proportion of looks (samples) to each interest area in a particular span of time (bin size). In order to do this, it is necessary to supply the parameters <code>BinSize</code> and <code>SamplingRate</code>. <code>BinSize</code> should be specified in milliseconds, representing the chunk of time within which to calculate the proportions.</p>
<p>Not all bin sizes work for all sampling rates, due to downsampling constraints. If unsure which are appropriate for your current sampling rate, use the <code>ds_options</code> function. When provided with the current sampling rate in <code>SamplingRate</code> (see above), the function will return a printed summary of the bin size options and their corresponding downsampled rate.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ds_options</span>(<span class="dt">SamplingRate =</span> <span class="dv">1000</span>)</code></pre></div>
<pre><code>## Bin size: 1 ms; Downsampled rate: 1000 Hz</code></pre>
<pre><code>## Bin size: 2 ms; Downsampled rate: 500 Hz</code></pre>
<pre><code>## Bin size: 4 ms; Downsampled rate: 250 Hz</code></pre>
<pre><code>## Bin size: 5 ms; Downsampled rate: 200 Hz</code></pre>
<pre><code>## Bin size: 8 ms; Downsampled rate: 125 Hz</code></pre>
<pre><code>## Bin size: 10 ms; Downsampled rate: 100 Hz</code></pre>
<pre><code>## Bin size: 20 ms; Downsampled rate: 50 Hz</code></pre>
<pre><code>## Bin size: 25 ms; Downsampled rate: 40 Hz</code></pre>
<pre><code>## Bin size: 40 ms; Downsampled rate: 25 Hz</code></pre>
<pre><code>## Bin size: 50 ms; Downsampled rate: 20 Hz</code></pre>
<pre><code>## Bin size: 100 ms; Downsampled rate: 10 Hz</code></pre>
<p>The <code>SamplingRate</code> parameter in <code>bin_prop</code> should be specified in Hertz (see <code>check_samplingrate</code>), representing the original sampling rate of the data and the <code>BinSize</code> should be specified in milliseconds (see <code>ds_options</code>), representing the span of time over which to calculate the proportion. The <code>bin_prop</code> function returns new columns corresponding to each interest area ID (e.g., <code>IA_1_C</code>, <code>IA_1_P</code>). The extension ‘_C’ indicates the count of samples in the bin and the extension ‘_P’ indicates the proportion.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat4 &lt;-<span class="st"> </span><span class="kw">bin_prop</span>(dat3, <span class="dt">NoIA =</span> <span class="dv">4</span>, <span class="dt">BinSize =</span> <span class="dv">20</span>, <span class="dt">SamplingRate =</span> <span class="dv">1000</span>)</code></pre></div>
<pre><code>## Sampling rate OK. You're good to go!</code></pre>
<pre><code>## Binning...</code></pre>
<pre><code>## Calculating proportions...</code></pre>
<pre><code>## There are 320 data points with less than 20 samples per bin.</code></pre>
<pre><code>## These can be examined and/or removed using the column 'NSamples'.</code></pre>
<pre><code>## These occur at time bin(s): 1180</code></pre>
<pre><code>## Subsequent Empirical Logit calculations may be influenced by the number of samples (depending on the number of observations requested).</code></pre>
<p>In performing the calculation, the function effectively downsamples the data. To check this and to know the new sampling rate, simply call the function <code>check_samplingrate</code> again.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">check_samplingrate</span>(dat4)</code></pre></div>
<pre><code>## Sampling rate(s) present in the data are: 50 Hz.</code></pre>
</div>
<div id="empirical-logits" class="section level2">
<h2>Empirical logits</h2>
<p>Proportions are inherently bound between 0 and 1 and are therefore not suitable for many types of analysis. Logits provide a transformation resulting in an unbounded measure (as well as weights which estimate the variance). The calculations contained in this package are based on: Barr, D. J., (2008) Analyzing ‘visual world’ eyetracking data using multilevel logistic regression, <em>Journal of Memory and Language</em>, <em>59</em>(4), 457–474. However, they have been modified to allow greater flexibility.</p>
<p>When using an empirical logit transformation it is important to keep two things in mind. The first is the number of observations (or samples) on which to base the calculation. Typically, this is the number of samples per bin, which varies depending on your original sampling rate and bin size.</p>
<p>To determine the number of samples per bin present in the data, use the function <code>check_samples_per_bin</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">check_samples_per_bin</span>(dat4)</code></pre></div>
<pre><code>## There are 20 samples per bin.</code></pre>
<pre><code>## One data point every 20 millisecond(s)</code></pre>
<p>However, a user may choose to define a different number of observations (because the number of samples is inherently linked to the sampling rate). Though, it is important to note that changing this value can drastically impact the results of the transformation and weight calculations. There are some safeguards within the transformation function to prevent users from choosing inadvisable values (though these safeguards can be overridden with the parameter <code>ObsOverride</code>). So, if in doubt, it is safest to use the number of samples present in your data (as indicated by <code>check_samples_per_bin</code>). The second things to keep in mind is the constant to be added in the transformation. Note that by default the calculation uses a constant of 0.5; however, the user can specify a different value to be used.</p>
<style>
im {
width: 100%;
text-align: center;
}
</style>
<p>If you are interested in visualizing the effect of both number of observations and constant on the result of the empirical logit transformation and weight calculations, please refer to the vignette <code>SR_Plotting</code>, which illustrates and discusses the function <code>plot_transformation_app</code>.</p>
<p>The function <code>transform_to_elogit</code> transforms the proportions to empirical logits and also calculates a weight for each value. The weight estimates the variance in each bin (because the variance of the logit depends on the mean). This is particularly important for regression analyses and should be specified in the model call (e.g., weight = 1 / <code>IA_1_wts</code>). As mentioned above, the function takes the number of observations in the parameter <code>ObsPerBin</code>. Here we use the number of samples per bin present in the data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat5 &lt;-<span class="st"> </span><span class="kw">transform_to_elogit</span>(dat4, <span class="dt">NoIA =</span> <span class="dv">4</span>, <span class="dt">ObsPerBin =</span> <span class="dv">20</span>)</code></pre></div>
<pre><code>## Number of Observations equal to Number of Samples. 
##  Calculation will be based on Number of Samples.</code></pre>
</div>
<div id="binomial-data" class="section level2">
<h2>Binomial data</h2>
<p>Some researchers may prefer to perform a binomial analysis. Therefore the function <code>create_binomial</code> uses (previously calculated) proportions and number of observations to create a success/failure column for each IA. This column is then a suitable response variable for logistic regression of the time series. As with the empirical logit transformation, a user may choose to define a number of observations that is different from the number of samples per bin. Because this can create artifacts in the scaling or more samples than are present in the data, safeguards are in place to prevent users from choosing inadvisable values (though these safeguards can be overridden with the parameter <code>ObsOverride</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat5a &lt;-<span class="st"> </span><span class="kw">create_binomial</span>(<span class="dt">data =</span> dat4, <span class="dt">NoIA =</span> <span class="dv">4</span>, <span class="dt">ObsPerBin =</span> <span class="dv">20</span>)</code></pre></div>
<pre><code>## Number of Observations equal to Number of Samples. 
##  Counts will remain as present in the data.</code></pre>
<p>By default the function will create a success/failure column for each IA in the data; however, it is also possible to create a custom column comparing looks between two specific interest areas. This is done by specifying the parameter <code>CustomBinom</code> with a vector of two integers (e.g., CustomBinom = c(1,2)) in which the two integers correspond to the IDs of the desired interest areas.</p>
</div>
<div id="fastrack-function" class="section level2">
<h2>Fastrack function</h2>
<p>For advanced users who have worked with the package functions before and who are familiar with the required steps and output, there is a meta-function, called <code>fasttrack</code>, which runs through the previous functions and outputs a dataframe with either empirical logits or binomial data. Note that using this function will still require the user to manually remove unneeded columns (see above). This meta-function takes as parameters all the required arguments to the component functions. Also, this function assumes that dynamic interest areas were used and do not need to be relabelled/reassigned. It also assumes an interest period was defined in Data Viewer relative to the critical stimulus, thus not requiring separate message alignment. Again, this is only recommended for users who have previously worked with visual world data, the functions contained in this package, and are confident that their data meet the requirements/assumptions of the <code>fasttrack</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat5b &lt;-<span class="st"> </span><span class="kw">fasttrack</span>(<span class="dt">data =</span> VWdat, <span class="dt">Subject =</span> <span class="st">&quot;RECORDING_SESSION_LABEL&quot;</span>, <span class="dt">Item =</span> <span class="st">&quot;itemid&quot;</span>, 
    <span class="dt">EventColumns =</span> <span class="kw">c</span>(<span class="st">&quot;Subject&quot;</span>, <span class="st">&quot;TRIAL_INDEX&quot;</span>), <span class="dt">NoIA =</span> <span class="dv">4</span>, <span class="dt">Adj =</span> -<span class="dv">100</span>, <span class="dt">Recording =</span> <span class="st">&quot;LandR&quot;</span>, 
  <span class="dt">WhenLandR =</span> <span class="st">&quot;Right&quot;</span>, <span class="dt">BinSize =</span> <span class="dv">20</span>, <span class="dt">SamplingRate =</span> <span class="dv">1000</span>,
  <span class="dt">ObsPerBin =</span> <span class="dv">20</span>, <span class="dt">Constant =</span> <span class="fl">0.5</span>, <span class="dt">Output =</span> <span class="st">&quot;ELogit&quot;</span>)</code></pre></div>
<pre><code>## Preparing data...</code></pre>
<pre><code>## Checking required columns...</code></pre>
<pre><code>##     All required columns are present in the data.</code></pre>
<pre><code>## Checking optional columns...</code></pre>
<pre><code>##     All optional columns are present in the data.</code></pre>
<pre><code>## Working on required columns...</code></pre>
<pre><code>##     RECORDING_SESSION_LABEL renamed to Subject.</code></pre>
<pre><code>##     Subject converted to factor.</code></pre>
<pre><code>##     itemid renamed to Item.</code></pre>
<pre><code>##     Item converted to factor.</code></pre>
<pre><code>##     LEFT_INTEREST_AREA_ID converted to numeric.</code></pre>
<pre><code>##     RIGHT_INTEREST_AREA_ID already numeric.</code></pre>
<pre><code>##     LEFT_INTEREST_AREA_LABEL converted to factor.</code></pre>
<pre><code>##     RIGHT_INTEREST_AREA_LABEL converted to factor.</code></pre>
<pre><code>##     TIMESTAMP already numeric.</code></pre>
<pre><code>##     TRIAL_INDEX already numeric.</code></pre>
<pre><code>##     Event variable created from Subject and TRIAL_INDEX</code></pre>
<pre><code>## Working on optional columns...</code></pre>
<pre><code>##     Optional column SAMPLE_MESSAGE already factor.</code></pre>
<pre><code>##     Optional column LEFT_GAZE_X converted to numeric.</code></pre>
<pre><code>##     Optional column LEFT_GAZE_Y converted to numeric.</code></pre>
<pre><code>##     Optional column RIGHT_GAZE_X already numeric.</code></pre>
<pre><code>##     Optional column RIGHT_GAZE_Y already numeric.</code></pre>
<pre><code>## Relabelling outside of 4 interest areas...</code></pre>
<pre><code>## LEFT_INTEREST_AREA_LABEL: Number of levels DO NOT match NoIA.</code></pre>
<pre><code>## RIGHT_INTEREST_AREA_LABEL: Number of levels match NoIA.</code></pre>
<pre><code>## Interest Area IDs for the right eye are coded appropriately.</code></pre>
<pre><code>##   ID      Label
## 1  0    Outside
## 2  1     Target
## 3  3  OnsetComp
## 4  2  RhymeComp
## 5  4 Distractor</code></pre>
<pre><code>## Interest Area IDs for the left eye are coded appropriately.</code></pre>
<pre><code>##   ID   Label
## 1  0 Outside</code></pre>
<pre><code>## Creating time series with -100 ms adjustment...</code></pre>
<pre><code>## [1] -100</code></pre>
<pre><code>## The dataset contains recordings for ONLY the right eye. 
##  Set the Recording parameter in select_recorded_eye() to 'R'.</code></pre>
<pre><code>## Selecting recorded eye...</code></pre>
<pre><code>## Gaze data summary for 320 events:</code></pre>
<pre><code>## 0 event(s) contained gaze data for both eyes, for which the Right eye has been selected.</code></pre>
<pre><code>## The final data frame contains 319 event(s) using gaze data from the right eye.</code></pre>
<pre><code>## The final data frame contains 0 event(s) using gaze data from the left eye.</code></pre>
<pre><code>## The final data frame contains 1 event(s) with no samples falling within any interest area during the given time series.</code></pre>
<pre><code>## Sampling rate(s) present in the data are: 1000 Hz.</code></pre>
<pre><code>## Binning 1000 Hz data into 20 ms bins...</code></pre>
<pre><code>## Calculating proportions...</code></pre>
<pre><code>## Sampling rate OK. You're good to go!</code></pre>
<pre><code>## Binning...</code></pre>
<pre><code>## Calculating proportions...</code></pre>
<pre><code>## There are 320 data points with less than 20 samples per bin.</code></pre>
<pre><code>## These can be examined and/or removed using the column 'NSamples'.</code></pre>
<pre><code>## These occur at time bin(s): 1180</code></pre>
<pre><code>## Subsequent Empirical Logit calculations may be influenced by the number of samples (depending on the number of observations requested).</code></pre>
<pre><code>## Sampling rate(s) present in the data are: 50 Hz.</code></pre>
<pre><code>## There are 20 samples per bin.</code></pre>
<pre><code>## One data point every 20 millisecond(s)</code></pre>
<pre><code>## Preparing ELogit output...</code></pre>
<pre><code>## Number of Observations equal to Number of Samples. 
##  Calculation will be based on Number of Samples.</code></pre>
</div>
<div id="renaming-interest-area-columns" class="section level2">
<h2>Renaming interest area columns</h2>
<p>Some may wish to rename the interest area columns created by the functions to something more meaningful than the numeric coding scheme. To do so, use the function <code>rename_columns</code>. This will convert column names like <code>IA_1_C</code> and <code>IA_2_P</code> to <code>IA_Target_C</code> and <code>IA_Rhyme_P</code>, respectively. This will perform the operation on all the <code>IA_</code> columns for upto 8 interest areas.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat6 &lt;-<span class="st"> </span><span class="kw">rename_columns</span>(dat5, <span class="dt">Labels =</span> <span class="kw">c</span>(<span class="dt">IA1=</span><span class="st">&quot;Target&quot;</span>, <span class="dt">IA2=</span><span class="st">&quot;Rhyme&quot;</span>, 
                                       <span class="dt">IA3=</span><span class="st">&quot;OnsetComp&quot;</span>, <span class="dt">IA4=</span><span class="st">&quot;Distractor&quot;</span>)) </code></pre></div>
<pre><code>## Renaming 4 interest areas.</code></pre>
<p>You can now check the column names in the data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">colnames</span>(dat6) </code></pre></div>
<p>[1] “Subject” “LEFT_GAZE_X”<br />
[3] “LEFT_GAZE_Y” “LEFT_INTEREST_AREA_ID”<br />
[5] “LEFT_INTEREST_AREA_LABEL” “RIGHT_GAZE_X”<br />
[7] “RIGHT_GAZE_Y” “RIGHT_INTEREST_AREA_ID”<br />
[9] “RIGHT_INTEREST_AREA_LABEL” “SAMPLE_MESSAGE”<br />
[11] “TIMESTAMP” “TRIAL_INDEX”<br />
[13] “target” “rhymecomp”<br />
[15] “onsetcomp” “distractor”<br />
[17] “talker” “cb”<br />
[19] “Gender” “Age”<br />
[21] “Rating” “InteractChinese”<br />
[23] “Exp” “Item”<br />
[25] “Event” “Time”<br />
[27] “EyeRecorded” “EyeSelected”<br />
[29] “IA_ID” “IA_LABEL”<br />
[31] “DS” “NSamples”<br />
[33] “IA_outside_C” “IA_Target_C”<br />
[35] “IA_Rhyme_C” “IA_OnsetComp_C”<br />
[37] “IA_Distractor_C” “IA_outside_P”<br />
[39] “IA_Target_P” “IA_Rhyme_P”<br />
[41] “IA_OnsetComp_P” “IA_Distractor_P”<br />
[43] “Obs” “IA_outside_ELogit”<br />
[45] “IA_outside_wts” “IA_Target_ELogit”<br />
[47] “IA_Target_wts” “IA_Rhyme_ELogit”<br />
[49] “IA_Rhyme_wts” “IA_OnsetComp_ELogit”<br />
[51] “IA_OnsetComp_wts” “IA_Distractor_ELogit”<br />
[53] “IA_Distractor_wts”</p>
</div>
<div id="saving-the-data" class="section level2">
<h2>Saving the data</h2>
<div id="subsetting-and-ordering" class="section level3">
<h3>Subsetting and ordering</h3>
<p>Before embarking on a statistical analysis, it is probably necessary to take a couple steps, such as paring down the data to only include the columns which will be needed later and ensuring the data are ordered appropriately. This is straightforward using <code>dplyr</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">FinalDat &lt;-<span class="st"> </span>dat5 %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="co"># Select just the columns you want</span>
<span class="st">  </span><span class="kw">select</span>(., Subject, Item, Time, <span class="kw">starts_with</span>(<span class="st">&quot;IA&quot;</span>), Event, TRIAL_INDEX, Rating, 
         InteractChinese, Exp, target, rhymecomp, onsetcomp, distractor) %&gt;%
<span class="st">  </span><span class="co"># Order the data by Subject, Trial, and Time</span>
<span class="st">  </span><span class="kw">arrange</span>(., Subject, TRIAL_INDEX, Time)</code></pre></div>
</div>
<div id="saving-to-a-file" class="section level3">
<h3>Saving to a file</h3>
<p>Save the resulting dataset to a .rda file and use compression to make it more compact (though this will add to the amount of time it takes to save).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">save</span>(FinalDat, <span class="dt">file =</span> <span class="st">&quot;FinalDat.rda&quot;</span>, <span class="dt">compress =</span> <span class="st">&quot;xz&quot;</span>)</code></pre></div>
</div>
</div>
<div id="plotting" class="section level2">
<h2>Plotting</h2>
<p>You are now ready to plot your data. Please refer to the vignette <code>SR_Plotting</code> for details on the various plotting functions contained in the package.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
